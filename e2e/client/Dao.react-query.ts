/**
* This file was automatically generated by @jmes-cosmwasm/ts-codegen@0.14.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @jmes-cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Duration, Threshold, Decimal, InstantiateMsg, Voter, ExecuteMsg, Expiration, Timestamp, Uint64, CosmosMsgForEmpty, BankMsg, Uint128, StakingMsg, DistributionMsg, WasmMsg, Binary, Vote, Coin, Empty, QueryMsg, Status, ThresholdResponse, ProposalListResponse, ProposalResponseForEmpty, VoterListResponse, VoterDetail, VoteListResponse, VoteInfo, NameResponse, VoteResponse, VoterResponse } from "./Dao.types";
import { DaoQueryClient, DaoClient } from "./Dao.client";
export const daoQueryKeys = {
  contract: ([{
    contract: "dao"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...daoQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  name: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "name",
    args
  }] as const),
  threshold: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "threshold",
    args
  }] as const),
  proposal: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "proposal",
    args
  }] as const),
  listProposals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "list_proposals",
    args
  }] as const),
  reverseProposals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "reverse_proposals",
    args
  }] as const),
  showVote: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "show_vote",
    args
  }] as const),
  listVotes: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "list_votes",
    args
  }] as const),
  voter: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "voter",
    args
  }] as const),
  listVoters: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoQueryKeys.address(contractAddress)[0],
    method: "list_voters",
    args
  }] as const)
};
export interface DaoReactQuery<TResponse, TData = TResponse> {
  client: DaoQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface DaoListVotersQuery<TData> extends DaoReactQuery<VoterListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useDaoListVotersQuery<TData = VoterListResponse>({
  client,
  args,
  options
}: DaoListVotersQuery<TData>) {
  return useQuery<VoterListResponse, Error, TData>(daoQueryKeys.listVoters(client?.contractAddress, args), () => client ? client.listVoters({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoVoterQuery<TData> extends DaoReactQuery<VoterResponse, TData> {
  args: {
    address: string;
  };
}
export function useDaoVoterQuery<TData = VoterResponse>({
  client,
  args,
  options
}: DaoVoterQuery<TData>) {
  return useQuery<VoterResponse, Error, TData>(daoQueryKeys.voter(client?.contractAddress, args), () => client ? client.voter({
    address: args.address
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoListVotesQuery<TData> extends DaoReactQuery<VoteListResponse, TData> {
  args: {
    limit?: number;
    proposalId: number;
    startAfter?: string;
  };
}
export function useDaoListVotesQuery<TData = VoteListResponse>({
  client,
  args,
  options
}: DaoListVotesQuery<TData>) {
  return useQuery<VoteListResponse, Error, TData>(daoQueryKeys.listVotes(client?.contractAddress, args), () => client ? client.listVotes({
    limit: args.limit,
    proposalId: args.proposalId,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoShowVoteQuery<TData> extends DaoReactQuery<VoteResponse, TData> {
  args: {
    proposalId: number;
    voter: string;
  };
}
export function useDaoShowVoteQuery<TData = VoteResponse>({
  client,
  args,
  options
}: DaoShowVoteQuery<TData>) {
  return useQuery<VoteResponse, Error, TData>(daoQueryKeys.showVote(client?.contractAddress, args), () => client ? client.showVote({
    proposalId: args.proposalId,
    voter: args.voter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoReverseProposalsQuery<TData> extends DaoReactQuery<ProposalListResponse, TData> {
  args: {
    limit?: number;
    startBefore?: number;
  };
}
export function useDaoReverseProposalsQuery<TData = ProposalListResponse>({
  client,
  args,
  options
}: DaoReverseProposalsQuery<TData>) {
  return useQuery<ProposalListResponse, Error, TData>(daoQueryKeys.reverseProposals(client?.contractAddress, args), () => client ? client.reverseProposals({
    limit: args.limit,
    startBefore: args.startBefore
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoListProposalsQuery<TData> extends DaoReactQuery<ProposalListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: number;
  };
}
export function useDaoListProposalsQuery<TData = ProposalListResponse>({
  client,
  args,
  options
}: DaoListProposalsQuery<TData>) {
  return useQuery<ProposalListResponse, Error, TData>(daoQueryKeys.listProposals(client?.contractAddress, args), () => client ? client.listProposals({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoProposalQuery<TData> extends DaoReactQuery<ProposalResponseForEmpty, TData> {
  args: {
    proposalId: number;
  };
}
export function useDaoProposalQuery<TData = ProposalResponseForEmpty>({
  client,
  args,
  options
}: DaoProposalQuery<TData>) {
  return useQuery<ProposalResponseForEmpty, Error, TData>(daoQueryKeys.proposal(client?.contractAddress, args), () => client ? client.proposal({
    proposalId: args.proposalId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoThresholdQuery<TData> extends DaoReactQuery<ThresholdResponse, TData> {}
export function useDaoThresholdQuery<TData = ThresholdResponse>({
  client,
  options
}: DaoThresholdQuery<TData>) {
  return useQuery<ThresholdResponse, Error, TData>(daoQueryKeys.threshold(client?.contractAddress), () => client ? client.threshold() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoNameQuery<TData> extends DaoReactQuery<NameResponse, TData> {}
export function useDaoNameQuery<TData = NameResponse>({
  client,
  options
}: DaoNameQuery<TData>) {
  return useQuery<NameResponse, Error, TData>(daoQueryKeys.name(client?.contractAddress), () => client ? client.name() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoCloseMutation {
  client: DaoClient;
  msg: {
    proposalId: number;
  };
  args?: {
    coins?: Coins;
  };
}
export function useDaoCloseMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoCloseMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoCloseMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.close(msg, coins), options);
}
export interface DaoExecuteMutation {
  client: DaoClient;
  msg: {
    proposalId: number;
  };
  args?: {
    coins?: Coins;
  };
}
export function useDaoExecuteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoExecuteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoExecuteMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.execute(msg, coins), options);
}
export interface DaoVoteMutation {
  client: DaoClient;
  msg: {
    proposalId: number;
    vote: Vote;
  };
  args?: {
    coins?: Coins;
  };
}
export function useDaoVoteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoVoteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoVoteMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.vote(msg, coins), options);
}
export interface DaoProposeMutation {
  client: DaoClient;
  msg: {
    description: string;
    latest?: Expiration;
    msgs: CosmosMsgForEmpty[];
    title: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useDaoProposeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoProposeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoProposeMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.propose(msg, coins), options);
}