/**
* This file was automatically generated by @jmes-cosmwasm/ts-codegen@0.14.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @jmes-cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { LCDClient, Coins, MnemonicKey, MsgExecuteContract, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Uint128, ConfigResponse, Empty, ExecuteMsg, Binary, Cw20ReceiveMsg, InstantiateMsg, QueryMsg } from "./ArtistCurator.types";
export interface ArtistCuratorReadOnlyInterface {
  contractAddress: string;
  getConfig: () => Promise<GetConfigResponse>;
}
export class ArtistCuratorQueryClient implements ArtistCuratorReadOnlyInterface {
  client: LCDClient;
  contractAddress: string;

  constructor(client: LCDClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getConfig = this.getConfig.bind(this);
  }

  getConfig = async (): Promise<GetConfigResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_config: {}
    });
  };
}
export interface ArtistCuratorInterface extends ArtistCuratorReadOnlyInterface {
  contractAddress: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, coins?: Coins) => Promise<WaitTxBroadcastResult>;
}
export class ArtistCuratorClient extends ArtistCuratorQueryClient implements ArtistCuratorInterface {
  client: LCDClient;
  user: any;
  contractAddress: string;

  constructor(client: LCDClient, user: any, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.user = user;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, coins?: Coins): Promise<WaitTxBroadcastResult> => {
    const key = new MnemonicKey(this.user.mnemonicKeyOptions);
    const wallet = this.client.wallet(key);
    const execMsg = new MsgExecuteContract(this.user.address, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, coins);
    const txOptions = { msgs: [execMsg] };
    const tx = await wallet.createAndSignTx(txOptions);
    return await this.client.tx.broadcast(tx);
  };
}