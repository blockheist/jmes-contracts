/**
* This file was automatically generated by @jmes-cosmwasm/ts-codegen@0.14.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @jmes-cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { LCDClient, Coins, MnemonicKey, MsgExecuteContract, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Uint128, ConfigResponse, Cw20HookMsg, Feature, ExecuteMsg, Binary, VoteOption, Cw20ReceiveMsg, InstantiateMsg, ProposalPeriod, PeriodInfoResponse, ProposalType, ProposalStatus, ProposalResponse, ProposalsResponse, QueryMsg } from "./Governance.types";
export interface GovernanceReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  periodInfo: () => Promise<PeriodInfoResponse>;
  proposal: ({
    id
  }: {
    id: number;
  }) => Promise<ProposalResponse>;
  proposals: ({
    limit,
    start
  }: {
    limit?: number;
    start?: number;
  }) => Promise<ProposalsResponse>;
}
export class GovernanceQueryClient implements GovernanceReadOnlyInterface {
  client: LCDClient;
  contractAddress: string;

  constructor(client: LCDClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.periodInfo = this.periodInfo.bind(this);
    this.proposal = this.proposal.bind(this);
    this.proposals = this.proposals.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      config: {}
    });
  };
  periodInfo = async (): Promise<PeriodInfoResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      period_info: {}
    });
  };
  proposal = async ({
    id
  }: {
    id: number;
  }): Promise<ProposalResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      proposal: {
        id
      }
    });
  };
  proposals = async ({
    limit,
    start
  }: {
    limit?: number;
    start?: number;
  }): Promise<ProposalsResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      proposals: {
        limit,
        start
      }
    });
  };
}
export interface GovernanceInterface extends GovernanceReadOnlyInterface {
  contractAddress: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, coins?: Coins) => Promise<WaitTxBroadcastResult>;
  vote: ({
    id,
    vote
  }: {
    id: number;
    vote: VoteOption;
  }, coins?: Coins) => Promise<WaitTxBroadcastResult>;
  conclude: ({
    id
  }: {
    id: number;
  }, coins?: Coins) => Promise<WaitTxBroadcastResult>;
  setContract: ({
    artistCurator,
    distribution,
    identityservice
  }: {
    artistCurator: string;
    distribution: string;
    identityservice: string;
  }, coins?: Coins) => Promise<WaitTxBroadcastResult>;
}
export class GovernanceClient extends GovernanceQueryClient implements GovernanceInterface {
  client: LCDClient;
  user: any;
  contractAddress: string;

  constructor(client: LCDClient, user: any, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.user = user;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.vote = this.vote.bind(this);
    this.conclude = this.conclude.bind(this);
    this.setContract = this.setContract.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, coins?: Coins): Promise<WaitTxBroadcastResult> => {
    const key = new MnemonicKey(this.user.mnemonicKeyOptions);
    const wallet = this.client.wallet(key);
    const execMsg = new MsgExecuteContract(this.user.address, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, coins);
    const txOptions = { msgs: [execMsg] };
    const tx = await wallet.createAndSignTx(txOptions);
    return await this.client.tx.broadcast(tx);
  };
  vote = async ({
    id,
    vote
  }: {
    id: number;
    vote: VoteOption;
  }, coins?: Coins): Promise<WaitTxBroadcastResult> => {
    const key = new MnemonicKey(this.user.mnemonicKeyOptions);
    const wallet = this.client.wallet(key);
    const execMsg = new MsgExecuteContract(this.user.address, this.contractAddress, {
      vote: {
        id,
        vote
      }
    }, coins);
    const txOptions = { msgs: [execMsg] };
    const tx = await wallet.createAndSignTx(txOptions);
    return await this.client.tx.broadcast(tx);
  };
  conclude = async ({
    id
  }: {
    id: number;
  }, coins?: Coins): Promise<WaitTxBroadcastResult> => {
    const key = new MnemonicKey(this.user.mnemonicKeyOptions);
    const wallet = this.client.wallet(key);
    const execMsg = new MsgExecuteContract(this.user.address, this.contractAddress, {
      conclude: {
        id
      }
    }, coins);
    const txOptions = { msgs: [execMsg] };
    const tx = await wallet.createAndSignTx(txOptions);
    return await this.client.tx.broadcast(tx);
  };
  setContract = async ({
    artistCurator,
    distribution,
    identityservice
  }: {
    artistCurator: string;
    distribution: string;
    identityservice: string;
  }, coins?: Coins): Promise<WaitTxBroadcastResult> => {
    const key = new MnemonicKey(this.user.mnemonicKeyOptions);
    const wallet = this.client.wallet(key);
    const execMsg = new MsgExecuteContract(this.user.address, this.contractAddress, {
      set_contract: {
        artist_curator: artistCurator,
        distribution,
        identityservice
      }
    }, coins);
    const txOptions = { msgs: [execMsg] };
    const tx = await wallet.createAndSignTx(txOptions);
    return await this.client.tx.broadcast(tx);
  };
}